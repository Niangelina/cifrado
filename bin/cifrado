#!/usr/bin/env ruby
require 'cifrado'
require 'yaml'

$0 = "cifrado #{ARGV.join(' ')}"

class CifradoCLI < Thor

  include Cifrado
  include Cifrado::Utils

  option :username
  option :password
  option :auth_url
  option :encrypt
  option :segments, :type => :numeric
  option :insecure, :type => :boolean
  option :no_progressbar, :type => :boolean

  desc "upload CONTAINER FILE", "Upload a file"
  def upload(container, file)

    config_file = File.join(ENV['HOME'], '.cifradorc')
    config = {}

    if File.exist?(config_file)
      begin
        Cifrado::Log.debug "Trying to read config file #{config_file}"
        config = YAML.load_file(config_file)
        Cifrado::Log.debug "Config #{config_file} read"
        original_config = config.dup
      rescue => e
        Cifrado::Log.error "Error loading config file"
        Cifrado::Log.error e.message
      end
    end

    config[:username] = options[:username] || config[:username] || ask('username:')
    if options[:password] or config[:password]
      config[:password] = options[:password] || config[:password]
    else
      system 'stty -echo -icanon'
      config[:password] = ask('password:')
      system 'stty echo icanon'
      puts
    end
    config[:auth_url] = options[:auth_url] || config[:auth_url] || ask('auth_url:')

    unless File.exist?(config_file)
      puts
      puts "Cifrado can save this settings in #{ENV['HOME']}/.cifradorc"
      puts "for later use."
      puts "The settings (password included) are saved unencrypted."
      puts
      if yes? "Do you want to save these settings?"
        File.open(config_file, 'w') do |f| 
          f.puts config.to_yaml
          f.chmod 0600
        end
        @settings_saved = true
      end
    end

    if original_config != config and !@settings_saved
      puts "username, password and/or auth_url changed"
      if yes? "Do you want to save the NEW settings?"
        File.open(config_file, 'w') { |f| f.puts config.to_yaml }
      end
    end

    begin 
      client = Cifrado::SwiftClient.new :username => config[:username], 
                                        :api_key  => config[:password],
                                        :auth_url => config[:auth_url],
                                        :connection_options => { :ssl_verify_peer => !options[:insecure] }

      if options[:segments]
        split_and_upload client, container, file, options
      else
        upload_single client, container, file, options
      end

    rescue Excon::Errors::Unauthorized => e
      Log.error set_color("Unauthorized.", :red, true)
      Log.error "Double check the username, password and auth_url."
    rescue Excon::Errors::SocketError => e
      if e.message =~ /Unable to verify certificate/
        Log.error "Unable to verify certificate. Try using --insecure."
      end
    end
  end

  private
  def upload_single(client, container, object, options)
    config = Cifrado::Config.instance
    if recipient = needs_encryption(options)
      cs = CryptoServices.new
      encrypted_file = File.join(config.cache_dir, File.basename(object))
      cs.encrypt object, encrypted_file, :recipient => recipient
      unless CryptoServices.encrypted?(encrypted_file)
        raise Exception.new "Could not encrypt segment #{segment}"
      end
      client.upload container, encrypted_file, :object_path => object
    else
    end
  end

  def needs_encryption(options)
    return nil unless options[:encrypt]

    tokens = options[:encrypt].split(':')
    etype = tokens.first
    etarget = tokens[1..-1].join(':')
    if etype == 'a'
      recipient = etarget
    elsif etype == 's'
      raise NotImplemented.new
    else
      raise "Invalid encryption type #{etype}."
    end
    recipient
  end

  def split_and_upload(client, container, object, options)
    config = Cifrado::Config.instance
    if options[:encrypt]
      recipient = needs_encryption(options)
      Log.debug "Encrypting object #{object} for recipient #{recipient}"
      cs = CryptoServices.new
      encrypted_file = File.join(config.cache_dir, File.basename(object))
      cs.encrypt object, encrypted_file, :recipient => recipient
    end
    
    if options[:encrypt] and !CryptoServices.encrypted?(encrypted_file)
      raise Exception.new "Could not encrypt file #{object}"
    end
    splitter = FileSplitter.new encrypted_file, options[:segments]
    splitter.split.each do |segment|
      puts "uploading segment #{segment}"
      segment_number = segment.split(splitter.chunk_suffix).last
      obj_path = object + splitter.chunk_suffix + segment_number
      Log.debug "Uploading segment #{obj_path}..."
      client.upload container, segment, :object_path => obj_path  
    end
    
    Log.debug "Adding manifest #{object}"
    client.service.put_object_manifest container, object.gsub(/^\//, '')
  end

end

CifradoCLI.start ARGV, :shell => Thor::Shell::Color.new
